
# abstract type for all missing data mechanisms
abstract type MissingMechanism end

# various missing data mechanisms according to Rubin (http://www.jstor.org/stable/2335739)
abstract type MCARMechanism <: MissingMechanism end
abstract type MARMechanism <: MissingMechanism end
abstract type MNARMechanism <: MissingMechanism end

# concrete types for each mechanism 
# MCAR - missing completely at random
struct BernoulliMCAR <: MCARMechanism end

# MAR - missing at random 
struct BlockMissingMAR <: MARMechanism end

# MNAR - missing not at random
struct LowestMNAR <: MNARMechanism end
struct HighestMNAR <: MNARMechanism end

percentage_missing_values(X::AbstractVector) = 100.0 * count(isnan, X) / length(X)

function remove_values(X::AbstractVector{<:T}, idxs::Vector{Int64}) where {T <: Number}
    Xc::Vector{promote_type(T, Float64)} = deepcopy(X); Xc[idxs] .= NaN
    return Xc 
end


"""
```Julia
mcar(
    X::AbstractVector, 
    fraction_missing::Float64, 
    mechanism::MCARMechanism=BernoulliMCAR(); 
    rng::AbstractRNG=Random.GLOBAL_RNG, 
    verbose::Bool=false
) -> Tuple{Vector{Float64}, Vector{Int64}}
```
Generate missing data using a Missing Completely At Random (MCAR) mechanism, where the probability 
of missingness is independent of both observed and unobserved values.
Available mechanisms:
- `BernoulliMCAR()`: Missing values are generated by sampling from a Bernoulli distribution with 
   probability `fraction_missing`.

# Arguments
- `X::AbstractVector`: Input time series data.
- `fraction_missing::Float64`: Target fraction of missing values, must be between 0 and 1 (default: 0.5).
- `mechanism::MCARMechanism`: Mechanism used to generate missing values (default: `BernoulliMCAR()`).
- `rng::AbstractRNG`: Random number generator for reproducibility (default: GLOBAL_RNG).
- `verbose::Bool`: If true, prints comparison of target vs actual percentage of missing values.

# Returns
- `X_corrupted::Vector`: Copy of input vector with NaN values at missing positions.
- `missing_idxs::Vector{Int64}`: Indices of missing values.
"""
function mcar(X::AbstractVector, fraction_missing::Float64=0.5, mechanism::MCARMechanism=BernoulliMCAR();
    rng::AbstractRNG=Random.GLOBAL_RNG, verbose::Bool=false)

    if !(0.0 ≤ fraction_missing ≤ 1.0)
        throw(ArgumentError("fraction_missing must be between 0 and 1"))
    end

    X_corrupted, missing_idxs = _mcar_sample(X, fraction_missing, rng, mechanism)
    if verbose
        actual_missing = percentage_missing_values(X_corrupted)
        println("Expected missing: $(100fraction_missing)%. Actual missing: $(round(actual_missing, digits=2))%")
    end
    
    return X_corrupted, missing_idxs

end

#=
Determine missing value indices by sampling from a [Bernoulli distribution](https://en.wikipedia.org/wiki/Bernoulli_distribution) 
with probability of success ``p`` determined by the target percentage missing.
Adapated from [Twala](https://www.tandfonline.com/doi/full/10.1080/08839510902872223).
=#
function _mcar_sample(X::AbstractVector, fraction_missing::Float64, rng::AbstractRNG, ::BernoulliMCAR)
    n = length(X)
    bernoulli_dist = Bernoulli(fraction_missing)
    mask = rand(rng, bernoulli_dist, n)
    missing_idxs = collect(1:n)[mask]
    X_corrupted = remove_values(X, missing_idxs)
    return X_corrupted, missing_idxs
end

"""
```Julia
mar(
    X::AbstractVector, 
    fraction_missing::Float64, 
    mechanism::MARMechanism=BlockMissingMAR();
    rng::AbstractRNG=Random.GLOBAL_RNG, 
    verbose::Bool=false
) -> Tuple{Vector{Float64}, Vector{Int64}}
```
Generate missing data using a Missing At Random (MAR) mechanism, where the probability of 
missingness depends only on observed values or known information.
Available mechanisms:
- `BlockMissingMAR()`: Generates a contiguous block of missing values with random start position.
 The missingness of each point after the first depends on the position of previous missing values.

# Arguments
- `X::AbstractVector`: Input time series data.
- `fraction_missing::Float64`: Target fraction of missing values, must be between 0 and 1 (default: 0.5).
- `mechanism::MARMechanism`: Mechanism used to generate missing values (default: `BlockMissingMAR()`)
- `rng::AbstractRNG`: Random number generator for reproducibility (default: GLOBAL_RNG).
- `verbose::Bool`: If true, prints comparison of target vs actual percentage of missing values.

# Returns
- `X_corrupted::Vector{Float64}`: Copy of input vector with NaN values at missing positions.
- `missing_idxs::Vector{Int64}`: Indices of missing values.
"""
function mar(
    X::AbstractVector, 
    fraction_missing::Float64=0.5, 
    mechanism::MARMechanism=BlockMissingMAR();
    rng::AbstractRNG=Random.GLOBAL_RNG, 
    verbose::Bool=false
)
    
    if !(0.0 ≤ fraction_missing ≤ 1.0)
        throw(ArgumentError("fraction_missing must be between 0 and 1"))
    end

    X_corrupted, missing_idxs = _mar_sample(X, fraction_missing, rng, mechanism)
    if verbose
        actual_missing = percentage_missing_values(X_corrupted)
        println("Expected missing: $(100fraction_missing)%. Actual missing: $(round(actual_missing, digits=2))%")
    end
    
    return X_corrupted, missing_idxs
end


#= 
Remove a consecutive "block" of observations with size specified by the fraction missing. 
The block location starting point is chosen randomly from a list of valid starting points
(given the block size) and subsequent elements are removed.
The chosen missing block depends solely on the time index (i.e., the starting point is 
selected uniformly from valid indices) and *not* on the underlying data values. 
Thus, the probability of being missing is independent of unobserved values, relying only on an 
observed variable (time). 
This makes the missing mechanism "Missing at Random."
=#
function _mar_sample(X::AbstractVector, fraction_missing::Float64, rng::AbstractRNG, ::BlockMissingMAR)
    n = length(X)
    npts_miss = round(Int, n * fraction_missing)
    start_idx = rand(rng, 1:(n-npts_miss+1)) # choose random starting location from valid locations
    missing_idxs = collect(start_idx:(start_idx+npts_miss - 1))
    X_corrupted = remove_values(X, missing_idxs)
    return X_corrupted, missing_idxs
end

"""
```julia
mnar(
    X::AbstractVector, 
    fraction_missing::Float64, 
    mechanism::MNARMechanism=LowestMNAR();
    verbose::Bool=false
) -> Tuple{Vector{Float64}, Vector{Int64}}
```
Generate missing data using a Missing Not At Random (MNAR) mechanism, where the probability 
of missingness depends on the unobserved values themselves.
Available mechanisms:
- `LowestMNAR()`: Introduces missing values at positions with the lowest values in the time series.
    Implementation as in [Twala 2019](https://www.tandfonline.com/doi/full/10.1080/08839510902872223). 
- `HighestMNAR()`: Introduces missing values at positions with the highest values in the time series.
    Implementation as in [Xia et al. 2017](https://www.sciencedirect.com/science/article/abs/pii/S0031320317301504).

# Arguments
- `X::AbstractVector`: Input time series data.
- `fraction_missing::Float64`: Target fraction of missing values, must be between 0 and 1 (default: 0.5).
- `mechanism::MNARMechanism`: Mechanism used to generate missing values (default: `LowestMNAR()`).
- `verbose::Bool`: If true, prints comparison of target vs actual percentage of missing values.

# Returns
- `X_corrupted::Vector{Float64}`: Copy of input vector with NaN values at missing positions.
- `missing_idxs::Vector{Int64}`: Indices of missing values.
"""
function mnar(
    X::AbstractVector, 
    fraction_missing::Float64=0.5, 
    mechanism::MNARMechanism=LowestMNAR();
    verbose::Bool=false
)

    if !(0.0 ≤ fraction_missing ≤ 1.0)
        throw(ArgumentError("fraction_missing must be between 0 and 1"))
    end

    X_corrupted, missing_idxs = _mnar_sample(X, fraction_missing, mechanism)
    if verbose
        actual_missing = percentage_missing_values(X_corrupted)
        println("Expected missing: $(100fraction_missing)%. Actual missing: $(round(actual_missing, digits=2))%")
    end
    
    return X_corrupted, missing_idxs
end

function _mnar_sample(X::AbstractVector, fraction_missing::Float64, ::LowestMNAR)
    npts = round(Int, length(X) * fraction_missing)
    missing_idxs = sortperm(X)[1:npts]
    X_corrupted = remove_values(X, missing_idxs)
    return X_corrupted, missing_idxs
end

# remove largest values as in [Xia et al. 2017](https://www.sciencedirect.com/science/article/abs/pii/S0031320317301504)
function _mnar_sample(X::AbstractVector, fraction_missing::Float64, ::HighestMNAR)
    npts = round(Int, length(X) * fraction_missing)
    missing_idxs = sortperm(X; rev=true)[1:npts]
    X_corrupted = remove_values(X, missing_idxs)
    return X_corrupted, missing_idxs
end
